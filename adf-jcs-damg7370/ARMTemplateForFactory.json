{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "adf-jcs-damg7370"
		},
		"AzureKeyVault1_properties_typeProperties_baseUrl": {
			"type": "string",
			"defaultValue": "https://jcs-demoadf.vault.azure.net/"
		},
		"ls_snowflake_chinook_db_properties_typeProperties_database": {
			"type": "string",
			"defaultValue": "@{linkedService().Database}"
		},
		"ls_snowflake_chinook_db_properties_typeProperties_role": {
			"type": "string",
			"defaultValue": "@{linkedService().Role}"
		},
		"ls_snowflake_chinook_db_properties_typeProperties_host": {
			"type": "string",
			"defaultValue": "@{linkedService().Host}"
		},
		"ls_snowflake_pet_properties_typeProperties_database": {
			"type": "string",
			"defaultValue": "@{linkedService().Database}"
		},
		"ls_snowflake_pet_properties_typeProperties_role": {
			"type": "string",
			"defaultValue": "@{linkedService().Role}"
		},
		"ls_snowflake_pet_properties_typeProperties_host": {
			"type": "string",
			"defaultValue": "@{linkedService().Host}"
		},
		"ls_sqldb_jcs_properties_typeProperties_server": {
			"type": "string",
			"defaultValue": "@{linkedService().Domainname}"
		},
		"ls_sqldb_jcs_properties_typeProperties_database": {
			"type": "string",
			"defaultValue": "DAMG7370FALL2025"
		},
		"ls_sqldb_jcs_properties_typeProperties_userName": {
			"type": "string",
			"defaultValue": "@{linkedService().Username}"
		},
		"ls_storage_azure_blob_properties_typeProperties_serviceEndpoint": {
			"type": "string",
			"defaultValue": "https://stgdamghw7370.blob.core.windows.net/"
		},
		"ls_storage_sas_auth_sasUri": {
			"type": "secureString",
			"metadata": "Secure string for 'sasUri' of 'ls_storage_sas_auth'"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/PL_Load_ARTIST_DIM')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Load_Artist_Dimension",
						"type": "Script",
						"dependsOn": [],
						"policy": {
							"timeout": "0.10:00:00",
							"retry": 2,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_snowflake_chinook_db",
							"type": "LinkedServiceReference",
							"parameters": {
								"Account": "QLHNMEQ-RTA20152",
								"Database": "chinook_db",
								"Warehouse": "COMPUTE_WH",
								"Username": "SEPULVEDAJU",
								"Role": "ACCOUNTADMIN",
								"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com"
							}
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "NonQuery",
									"text": "MERGE INTO CHINOOK_DB.DW.ARTIST_DIM AS target\r\nUSING (\r\n    SELECT \r\n        artistid,\r\n        name,\r\n        'CHINOOK' AS source_id,\r\n        ROW_NUMBER() OVER (ORDER BY artistid) + \r\n        COALESCE((SELECT MAX(ARTIST_KEY) FROM CHINOOK_DB.DW.ARTIST_DIM), 0) AS new_key\r\n    FROM CHINOOK_DB.STAGE.ARTIST\r\n) AS source\r\nON target.ARTIST_ID = source.artistid\r\n\r\nWHEN MATCHED AND (\r\n    COALESCE(target.ARTIST_NAME, '') <> COALESCE(source.name, '')\r\n) THEN\r\n    UPDATE SET\r\n        target.ARTIST_NAME = source.name,\r\n        target.DATE_TO_WAREHOUSE = CURRENT_TIMESTAMP()\r\n\r\nWHEN NOT MATCHED THEN\r\n    INSERT (\r\n        ARTIST_KEY,\r\n        ARTIST_ID,\r\n        ARTIST_NAME,\r\n        SOURCE_ID,\r\n        DATE_TO_WAREHOUSE\r\n    )\r\n    VALUES (\r\n        source.new_key,\r\n        source.artistid,\r\n        source.name,\r\n        source.source_id,\r\n        CURRENT_TIMESTAMP()\r\n    );"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"lastPublishTime": "2025-10-12T06:32:47Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_snowflake_chinook_db')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PL_Load_Customer_Dim')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Execute Customer DIm Load",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "Customer_Dataflow",
								"type": "DataFlowReference",
								"parameters": {
									"table_name": "'CUSTOMER_DIM'"
								},
								"datasetParameters": {
									"CustomerStage": {
										"schema_name": "STAGE",
										"table_name": "CUSTOMER"
									},
									"sourceCustomerDIm": {
										"schema_name": "DW",
										"table_name": "CUSTOMER_DIM"
									},
									"FinalStageSnowFlake": {
										"schema_name": "DW",
										"table_name": "CUSTOMER_DIM"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"lastPublishTime": "2025-10-12T06:04:15Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/Customer_Dataflow')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PL_Master_Pet')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "locationload2parque",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "csv2parque",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "state_fips",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "state_fips",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "state",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "state",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "state_abbr",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "state_abbr",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "zipcode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "zipcode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "county",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "county",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "city",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "city",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "location_ds",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Parquet_ds",
								"type": "DatasetReference",
								"parameters": {
									"container_name": "stageteamdata",
									"folder_name": "folder",
									"file_name": {
										"value": "@concat('location.parquet')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "LoadSTGtables",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "locationload2parque",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "Load_pet_location_Dataflow",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"locationsource": {
										"container_name": "stageteamdata",
										"folder_name": "folder",
										"file_name": "location.parquet"
									},
									"petlicensesource": {
										"container_name": "stageteamdata",
										"folder_name": "folder",
										"file_name": "petlicense.parquet"
									},
									"LocationStage": {
										"schema_name": "STAGE",
										"table_name": "LOCATION"
									},
									"Petstage": {
										"schema_name": "STAGE",
										"table_name": "PET_LICENSE"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "csv2parque",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobStorageWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"logSettings": {
								"enableCopyActivityLog": true,
								"copyActivityLogSettings": {
									"logLevel": "Warning",
									"enableReliableLogging": false
								},
								"logLocationSettings": {
									"linkedServiceName": {
										"referenceName": "ls_storage_azure_blob",
										"type": "LinkedServiceReference"
									}
								}
							},
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "License Issue Date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "License_Issue_Date",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "License Number",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "License_Number",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Animal Name",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Animal_Name",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Species",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Species",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Primary Breed",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Primary_Breed",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Secondary Breed",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Secondary_Breed",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ZIP Code",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Zip_Code",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "pet_ds",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Parquet_ds",
								"type": "DatasetReference",
								"parameters": {
									"container_name": "stageteamdata",
									"folder_name": "folder",
									"file_name": {
										"value": "@concat('petlicense.parquet')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Load_Dim_Date",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "LoadSTGtables",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_snowflake_pet",
							"type": "LinkedServiceReference",
							"parameters": {
								"Account": "QLHNMEQ-RTA20152",
								"Database": "pet_db",
								"Warehouse": "COMPUTE_WH",
								"Username": "SEPULVEDAJU",
								"Role": "ACCOUNTADMIN",
								"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com",
								"Schema": "DW"
							}
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "USE SCHEMA DW;\nMERGE INTO DATE_DIM AS tgt\nUSING (\n    WITH DATE_RANGE AS (\n        SELECT \n            DATEADD(DAY, SEQ4(), '2010-01-01')::DATE AS FULL_DATE\n        FROM TABLE(GENERATOR(ROWCOUNT => 7305))  -- 20 years of dates (2010-2030)\n    )\n    SELECT \n        TO_NUMBER(TO_CHAR(FULL_DATE, 'YYYYMMDD')) AS DATE_KEY,\n        FULL_DATE,\n        DAYOFWEEK(FULL_DATE) AS DAY_OF_WEEK,\n        DAYNAME(FULL_DATE) AS DAY_NAME,\n        DAY(FULL_DATE) AS DAY_OF_MONTH,\n        DAYOFYEAR(FULL_DATE) AS DAY_OF_YEAR,\n        WEEKOFYEAR(FULL_DATE) AS WEEK_OF_YEAR,\n        MONTH(FULL_DATE) AS MONTH_NUMBER,\n        MONTHNAME(FULL_DATE) AS MONTH_NAME,\n        TO_CHAR(FULL_DATE, 'MON') AS MONTH_ABBR,\n        QUARTER(FULL_DATE) AS QUARTER,\n        CONCAT('Q', QUARTER(FULL_DATE)) AS QUARTER_NAME,\n        YEAR(FULL_DATE) AS YEAR,\n        CASE \n            WHEN MONTH(FULL_DATE) >= 7 THEN YEAR(FULL_DATE) + 1\n            ELSE YEAR(FULL_DATE)\n        END AS FISCAL_YEAR,\n        CASE WHEN DAYOFWEEK(FULL_DATE) IN (0, 6) THEN TRUE ELSE FALSE END AS IS_WEEKEND,\n        FALSE AS IS_HOLIDAY  -- Update manually or with holiday logic\n    FROM DATE_RANGE\n) AS src\nON tgt.DATE_KEY = src.DATE_KEY\nWHEN NOT MATCHED THEN\n    INSERT (\n        DATE_KEY,\n        FULL_DATE,\n        DAY_OF_WEEK,\n        DAY_NAME,\n        DAY_OF_MONTH,\n        DAY_OF_YEAR,\n        WEEK_OF_YEAR,\n        MONTH_NUMBER,\n        MONTH_NAME,\n        MONTH_ABBR,\n        QUARTER,\n        QUARTER_NAME,\n        YEAR,\n        FISCAL_YEAR,\n        IS_WEEKEND,\n        IS_HOLIDAY,\n        LOAD_TIMESTAMP,\n        SOURCE_FILE_NAME\n    )\n    VALUES (\n        src.DATE_KEY,\n        src.FULL_DATE,\n        src.DAY_OF_WEEK,\n        src.DAY_NAME,\n        src.DAY_OF_MONTH,\n        src.DAY_OF_YEAR,\n        src.WEEK_OF_YEAR,\n        src.MONTH_NUMBER,\n        src.MONTH_NAME,\n        src.MONTH_ABBR,\n        src.QUARTER,\n        src.QUARTER_NAME,\n        src.YEAR,\n        src.FISCAL_YEAR,\n        src.IS_WEEKEND,\n        src.IS_HOLIDAY,\n        CURRENT_TIMESTAMP(),\n        'ADF_DATE_DIM_LOAD'\n    );\n\n"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "Load_Location_Dim",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "Load_Dim_Date",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_snowflake_pet",
							"type": "LinkedServiceReference",
							"parameters": {
								"Account": "QLHNMEQ-RTA20152",
								"Database": "pet_db",
								"Warehouse": "COMPUTE_WH",
								"Username": "SEPULVEDAJU",
								"Role": "ACCOUNTADMIN",
								"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com",
								"Schema": "DW"
							}
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "\r\n\r\nMERGE INTO PET_DB.DW.LOCATION_DIM AS TGT\r\nUSING (\r\n    SELECT \r\n        CONCAT(STATE_FIPS, '-', ZIPCODE) AS LOCATION_ID,\r\n        STATE_FIPS,\r\n        STATE_ABBR,\r\n        STATE,\r\n        ZIPCODE,\r\n        COUNTY,\r\n        CITY,\r\n        LOAD_TIMESTAMP,\r\n        SOURCE_FILE_NAME\r\n    FROM PET_DB.STAGE.LOCATION\r\n) AS SRC\r\nON TGT.LOCATION_ID = SRC.LOCATION_ID\r\n\r\n-- Update existing records\r\nWHEN MATCHED THEN UPDATE SET\r\n    TGT.STATE_FIPS = SRC.STATE_FIPS,\r\n    TGT.STATE_ABBR = SRC.STATE_ABBR,\r\n    TGT.STATE = SRC.STATE,\r\n    TGT.ZIPCODE = SRC.ZIPCODE,\r\n    TGT.COUNTY = SRC.COUNTY,\r\n    TGT.CITY = SRC.CITY,\r\n    TGT.SOURCE_FILE_NAME = SRC.SOURCE_FILE_NAME\r\n\r\n-- Insert new records\r\nWHEN NOT MATCHED THEN\r\n    INSERT (\r\n        LOCATION_ID,\r\n        STATE_FIPS,\r\n        STATE_ABBR,\r\n        STATE,\r\n        ZIPCODE,\r\n        COUNTY,\r\n        CITY,\r\n        LOAD_TIMESTAMP,\r\n        SOURCE_FILE_NAME\r\n    )\r\n    VALUES (\r\n        SRC.LOCATION_ID,\r\n        SRC.STATE_FIPS,\r\n        SRC.STATE_ABBR,\r\n        SRC.STATE,\r\n        SRC.ZIPCODE,\r\n        SRC.COUNTY,\r\n        SRC.CITY,\r\n        SRC.LOAD_TIMESTAMP,\r\n        SRC.SOURCE_FILE_NAME\r\n    );\r\n\r\n"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					},
					{
						"name": "BreedDimDataflow",
						"type": "ExecuteDataFlow",
						"dependsOn": [
							{
								"activity": "Load_Location_Dim",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "Breed_Dim_Dataflow",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"stagepet": {
										"schema_name": "STAGE",
										"table_name": "PET_LICENSE"
									},
									"BreedDim": {
										"schema_name": "DW",
										"table_name": "BREED_DIM"
									},
									"sink1": {
										"schema_name": "DW",
										"table_name": "BREED_DIM"
									}
								}
							},
							"staging": {},
							"compute": {
								"coreCount": 8,
								"computeType": "General"
							},
							"traceLevel": "Fine"
						}
					},
					{
						"name": "Fact_load",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "BreedDimDataflow",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "ls_snowflake_pet",
							"type": "LinkedServiceReference",
							"parameters": {
								"Account": "QLHNMEQ-RTA20152",
								"Database": "pet_db",
								"Warehouse": "COMPUTE_WH",
								"Username": "SEPULVEDAJU",
								"Role": "ACCOUNTADMIN",
								"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com",
								"Schema": "DW"
							}
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": "-- MERGE into PETLICENSE_FACT from stage tables\r\nMERGE INTO PET_DB.DW.PETLICENSE_FACT AS target\r\nUSING (\r\n    SELECT \r\n        stg.LICENSE_NUMBER,\r\n        dd.DATE_KEY AS LICENSE_ISSUE_DATE_KEY,\r\n        bd.BREED_KEY,\r\n        ld.LOCATION_KEY,\r\n        1 AS LICENSE_COUNT,\r\n        stg.SOURCE_FILE_NAME\r\n    FROM PET_DB.STAGE.PET_LICENSE stg\r\n    INNER JOIN PET_DB.DW.DATE_DIM dd \r\n        ON stg.LICENSE_ISSUE_DATE = dd.FULL_DATE\r\n    INNER JOIN PET_DB.DW.BREED_DIM bd \r\n        ON stg.PRIMARY_BREED = bd.PRIMARY_BREED \r\n        AND COALESCE(stg.SECONDARY_BREED, '') = COALESCE(bd.SECONDARY_BREED, '')\r\n    INNER JOIN PET_DB.DW.LOCATION_DIM ld \r\n        ON stg.ZIP_CODE = ld.ZIPCODE\r\n    WHERE stg.LICENSE_NUMBER IS NOT NULL\r\n) AS source\r\nON target.LICENSE_NUMBER = source.LICENSE_NUMBER\r\nWHEN MATCHED THEN\r\n    UPDATE SET\r\n        target.LICENSE_ISSUE_DATE_KEY = source.LICENSE_ISSUE_DATE_KEY,\r\n        target.BREED_KEY = source.BREED_KEY,\r\n        target.LOCATION_KEY = source.LOCATION_KEY,\r\n        target.LICENSE_COUNT = source.LICENSE_COUNT,\r\n        target.LOAD_TIMESTAMP = CURRENT_TIMESTAMP(),\r\n        target.SOURCE_FILE_NAME = source.SOURCE_FILE_NAME\r\nWHEN NOT MATCHED THEN\r\n    INSERT (\r\n        LICENSE_NUMBER,\r\n        LICENSE_ISSUE_DATE_KEY,\r\n        BREED_KEY,\r\n        LOCATION_KEY,\r\n        LICENSE_COUNT,\r\n        LOAD_TIMESTAMP,\r\n        SOURCE_FILE_NAME\r\n    )\r\n    VALUES (\r\n        source.LICENSE_NUMBER,\r\n        source.LICENSE_ISSUE_DATE_KEY,\r\n        source.BREED_KEY,\r\n        source.LOCATION_KEY,\r\n        source.LICENSE_COUNT,\r\n        CURRENT_TIMESTAMP(),\r\n        source.SOURCE_FILE_NAME\r\n    );\r\n\r\n"
								}
							],
							"scriptBlockExecutionTimeout": "02:00:00"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "Team_Project_Pet"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/location_ds')]",
				"[concat(variables('factoryId'), '/datasets/Parquet_ds')]",
				"[concat(variables('factoryId'), '/dataflows/Load_pet_location_Dataflow')]",
				"[concat(variables('factoryId'), '/datasets/pet_ds')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_snowflake_pet')]",
				"[concat(variables('factoryId'), '/dataflows/Breed_Dim_Dataflow')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/PL_To_Parque_filles')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ForEachTable",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.table_name",
								"type": "Expression"
							},
							"batchCount": 6,
							"activities": [
								{
									"name": "Parque_2_snowflake",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "ParquetSource",
											"storeSettings": {
												"type": "AzureBlobStorageReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "ParquetReadSettings"
											}
										},
										"sink": {
											"type": "SnowflakeV2Sink",
											"importSettings": {
												"type": "SnowflakeImportCopyCommand"
											}
										},
										"enableStaging": true,
										"stagingSettings": {
											"linkedServiceName": {
												"referenceName": "ls_storage_sas_auth",
												"type": "LinkedServiceReference"
											},
											"path": "stagedata2"
										}
									},
									"inputs": [
										{
											"referenceName": "Parquet_ds",
											"type": "DatasetReference",
											"parameters": {
												"container_name": "stagedata2",
												"folder_name": "fileupload",
												"file_name": {
													"value": "@concat(item(),'.parquet')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "snowflake_chinook_ds",
											"type": "DatasetReference",
											"parameters": {
												"schema_name": "STAGE",
												"table_name": {
													"value": "@toUpper(item())",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"folder_name": {
						"type": "string"
					},
					"table_name": {
						"type": "array",
						"defaultValue": [
							"Artist",
							"Album",
							"Customer",
							"Invoice",
							"InvoiceLine",
							"Genre"
						]
					}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"lastPublishTime": "2025-10-12T14:42:54Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/Parquet_ds')]",
				"[concat(variables('factoryId'), '/datasets/snowflake_chinook_ds')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_sas_auth')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/extract_db_sql')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "ForEachDsTable",
						"type": "ForEach",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@pipeline().parameters.table_array",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 6,
							"activities": [
								{
									"name": "parque_extract",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "SqlServerSource",
											"sqlReaderQuery": {
												"value": "SELECT \n    *,\n    'Julio Sepulveda' AS Created_by,\n    FORMAT(GETDATE(), 'yyyy-MM-dd') AS Created_dt\nFROM chinook.[@{item()}]",
												"type": "Expression"
											},
											"queryTimeout": "02:00:00",
											"partitionOption": "None"
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobStorageWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"logSettings": {
											"enableCopyActivityLog": true,
											"copyActivityLogSettings": {
												"logLevel": "Warning",
												"enableReliableLogging": false
											},
											"logLocationSettings": {
												"linkedServiceName": {
													"referenceName": "ls_storage_azure_blob",
													"type": "LinkedServiceReference"
												}
											}
										},
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "sqlserver_table_ds",
											"type": "DatasetReference",
											"parameters": {
												"schema_name": "chinook",
												"table_name": {
													"value": "@item()",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "Parquet_ds",
											"type": "DatasetReference",
											"parameters": {
												"container_name": "stagedata2",
												"folder_name": "fileupload",
												"file_name": {
													"value": "@concat(item(),'.parquet')",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"table_array": {
						"type": "array",
						"defaultValue": [
							"Artist",
							"Album",
							"Customer",
							"Invoice",
							"InvoiceLine",
							"Genre"
						]
					}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"lastPublishTime": "2025-10-11T23:48:26Z"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/sqlserver_table_ds')]",
				"[concat(variables('factoryId'), '/datasets/Parquet_ds')]",
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Parquet2snowflake')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_azure_blob",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"container_name": {
						"type": "string"
					},
					"folder_name": {
						"type": "string"
					},
					"file_name": {
						"type": "string"
					}
				},
				"folder": {
					"name": "Team_Project_Pet"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().folder_name",
							"type": "Expression"
						},
						"container": {
							"value": "@dataset().container_name",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Parquet_ds')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_azure_blob",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"container_name": {
						"type": "string",
						"defaultValue": "stagedata2"
					},
					"folder_name": {
						"type": "string",
						"defaultValue": "fileupload"
					},
					"file_name": {
						"type": "string",
						"defaultValue": "invoice"
					}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": {
							"value": "@dataset().file_name",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().folder_name",
							"type": "Expression"
						},
						"container": {
							"value": "@dataset().container_name",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/location_ds')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_azure_blob",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Team_Project_Pet"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "geo-data.csv",
						"folderPath": "folder",
						"container": "stageteamdata"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "state_fips",
						"type": "String"
					},
					{
						"name": "state",
						"type": "String"
					},
					{
						"name": "state_abbr",
						"type": "String"
					},
					{
						"name": "zipcode",
						"type": "String"
					},
					{
						"name": "county",
						"type": "String"
					},
					{
						"name": "city",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_snowflake_pet')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_snowflake_pet",
					"type": "LinkedServiceReference",
					"parameters": {
						"Account": "QLHNMEQ-RTA20152",
						"Database": "pet_db",
						"Warehouse": "COMPUTE_WH",
						"Username": "SEPULVEDAJU",
						"Role": "ACCOUNTADMIN",
						"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com",
						"Schema": "DW"
					}
				},
				"parameters": {
					"schema_name": {
						"type": "string",
						"defaultValue": "STAGE"
					},
					"table_name": {
						"type": "string",
						"defaultValue": "LOCATION"
					}
				},
				"folder": {
					"name": "Team_Project_Pet"
				},
				"annotations": [],
				"type": "SnowflakeV2Table",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().schema_name",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().table_name",
						"type": "Expression"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_snowflake_pet')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pet_ds')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_storage_azure_blob",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "Team_Project_Pet"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "Seattle_Pet_Licenses_20251012.csv",
						"folderPath": "folder",
						"container": "stageteamdata"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "License Issue Date",
						"type": "String"
					},
					{
						"name": "License Number",
						"type": "String"
					},
					{
						"name": "Animal's Name",
						"type": "String"
					},
					{
						"name": "Species",
						"type": "String"
					},
					{
						"name": "Primary Breed",
						"type": "String"
					},
					{
						"name": "Secondary Breed",
						"type": "String"
					},
					{
						"name": "ZIP Code",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_storage_azure_blob')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/snowflake_chinook_ds')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_snowflake_chinook_db",
					"type": "LinkedServiceReference",
					"parameters": {
						"Account": "QLHNMEQ-RTA20152",
						"Database": "chinook_db",
						"Warehouse": "COMPUTE_WH",
						"Username": "SEPULVEDAJU",
						"Role": "ACCOUNTADMIN",
						"Host": "QLHNMEQ-RTA20152.snowflakecomputing.com"
					}
				},
				"parameters": {
					"schema_name": {
						"type": "string",
						"defaultValue": "chinook"
					},
					"table_name": {
						"type": "String"
					}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"type": "SnowflakeV2Table",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().schema_name",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().table_name",
						"type": "Expression"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_snowflake_chinook_db')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/sqlserver_table_ds')]",
			"type": "Microsoft.DataFactory/factories/datasets",
			"apiVersion": "2018-06-01",
			"properties": {
				"linkedServiceName": {
					"referenceName": "ls_sqldb_jcs",
					"type": "LinkedServiceReference",
					"parameters": {
						"Domainname": "CESAR\\MSSQLSERVER01",
						"Username": "fall2025"
					}
				},
				"parameters": {
					"schema_name": {
						"type": "string",
						"defaultValue": "chinook"
					},
					"table_name": {
						"type": "string",
						"defaultValue": "Customer"
					}
				},
				"folder": {
					"name": "Individual_Project"
				},
				"annotations": [],
				"type": "SqlServerTable",
				"schema": [],
				"typeProperties": {
					"schema": {
						"value": "@dataset().schema_name",
						"type": "Expression"
					},
					"table": {
						"value": "@dataset().table_name",
						"type": "Expression"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/ls_sqldb_jcs')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/AzureKeyVault1')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureKeyVault",
				"typeProperties": {
					"baseUrl": "[parameters('AzureKeyVault1_properties_typeProperties_baseUrl')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_snowflake_chinook_db')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"parameters": {
					"Account": {
						"type": "String",
						"defaultValue": "QLHNMEQ-RTA20152"
					},
					"Database": {
						"type": "String",
						"defaultValue": "chinook_db"
					},
					"Warehouse": {
						"type": "String",
						"defaultValue": "COMPUTE_WH"
					},
					"Username": {
						"type": "string",
						"defaultValue": "SEPULVEDAJU"
					},
					"Role": {
						"type": "string",
						"defaultValue": "ACCOUNTADMIN"
					},
					"Host": {
						"type": "string",
						"defaultValue": "QLHNMEQ-RTA20152.snowflakecomputing.com"
					}
				},
				"annotations": [],
				"type": "SnowflakeV2",
				"typeProperties": {
					"authenticationType": "Basic",
					"accountIdentifier": "@{linkedService().Account}",
					"user": "@{linkedService().Username}",
					"database": "[parameters('ls_snowflake_chinook_db_properties_typeProperties_database')]",
					"warehouse": "@{linkedService().Warehouse}",
					"role": "[parameters('ls_snowflake_chinook_db_properties_typeProperties_role')]",
					"host": "[parameters('ls_snowflake_chinook_db_properties_typeProperties_host')]",
					"password": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault1",
							"type": "LinkedServiceReference"
						},
						"secretName": "snowflakechinook"
					}
				},
				"version": "1.1"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureKeyVault1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_snowflake_pet')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"parameters": {
					"Account": {
						"type": "String",
						"defaultValue": "QLHNMEQ-RTA20152"
					},
					"Database": {
						"type": "String",
						"defaultValue": "pet_db"
					},
					"Warehouse": {
						"type": "String",
						"defaultValue": "COMPUTE_WH"
					},
					"Username": {
						"type": "string",
						"defaultValue": "SEPULVEDAJU"
					},
					"Role": {
						"type": "string",
						"defaultValue": "ACCOUNTADMIN"
					},
					"Host": {
						"type": "string",
						"defaultValue": "QLHNMEQ-RTA20152.snowflakecomputing.com"
					},
					"Schema": {
						"type": "string",
						"defaultValue": "DW"
					}
				},
				"annotations": [],
				"type": "SnowflakeV2",
				"typeProperties": {
					"authenticationType": "Basic",
					"accountIdentifier": "@{linkedService().Account}",
					"user": "@{linkedService().Username}",
					"database": "[parameters('ls_snowflake_pet_properties_typeProperties_database')]",
					"warehouse": "@{linkedService().Warehouse}",
					"role": "[parameters('ls_snowflake_pet_properties_typeProperties_role')]",
					"host": "[parameters('ls_snowflake_pet_properties_typeProperties_host')]",
					"password": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault1",
							"type": "LinkedServiceReference"
						},
						"secretName": "snowflakechinook"
					},
					"schema": "@linkedService().Schema"
				},
				"version": "1.1"
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/linkedServices/AzureKeyVault1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_sqldb_jcs')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"parameters": {
					"Domainname": {
						"type": "String",
						"defaultValue": "CESAR\\MSSQLSERVER01"
					},
					"Username": {
						"type": "String",
						"defaultValue": "fall2025"
					}
				},
				"annotations": [],
				"type": "SqlServer",
				"typeProperties": {
					"server": "[parameters('ls_sqldb_jcs_properties_typeProperties_server')]",
					"database": "[parameters('ls_sqldb_jcs_properties_typeProperties_database')]",
					"encrypt": "True",
					"trustServerCertificate": true,
					"authenticationType": "SQL",
					"userName": "[parameters('ls_sqldb_jcs_properties_typeProperties_userName')]",
					"password": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "AzureKeyVault1",
							"type": "LinkedServiceReference"
						},
						"secretName": "sqlserver-credentials"
					},
					"pooling": "False",
					"multipleActiveResultSets": "False",
					"commandTimeout": "30"
				},
				"connectVia": {
					"referenceName": "integrationRuntime1",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/integrationRuntimes/integrationRuntime1')]",
				"[concat(variables('factoryId'), '/linkedServices/AzureKeyVault1')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_storage_azure_blob')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"serviceEndpoint": "[parameters('ls_storage_azure_blob_properties_typeProperties_serviceEndpoint')]",
					"accountKind": "StorageV2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ls_storage_sas_auth')]",
			"type": "Microsoft.DataFactory/factories/linkedServices",
			"apiVersion": "2018-06-01",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"sasUri": "[parameters('ls_storage_sas_auth_sasUri')]"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/integrationRuntime1')]",
			"type": "Microsoft.DataFactory/factories/integrationRuntimes",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "SelfHosted",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/Breed_Dim_Dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ls_snowflake_pet",
								"type": "DatasetReference"
							},
							"name": "stagepet"
						},
						{
							"dataset": {
								"referenceName": "ls_snowflake_pet",
								"type": "DatasetReference"
							},
							"name": "BreedDim"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ls_snowflake_pet",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "aggregate1"
						},
						{
							"name": "BreedID"
						},
						{
							"name": "join1"
						},
						{
							"name": "alterRow1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          LICENSE_ID as decimal(38,0),",
						"          LICENSE_ISSUE_DATE as date,",
						"          LICENSE_NUMBER as string,",
						"          ANIMAL_NAME as string,",
						"          SPECIES as string,",
						"          PRIMARY_BREED as string,",
						"          SECONDARY_BREED as string,",
						"          ZIP_CODE as string,",
						"          LOAD_TIMESTAMP as timestamp,",
						"          SOURCE_FILE_NAME as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     query: 'select * from STAGE.PET_LICENSE\\n',",
						"     format: 'query') ~> stagepet",
						"source(output(",
						"          BREED_KEY as decimal(38,0),",
						"          BREED_ID as string,",
						"          SPECIES_NAME as string,",
						"          PRIMARY_BREED as string,",
						"          SECONDARY_BREED as string,",
						"          LOAD_TIMESTAMP as timestamp,",
						"          SOURCE_FILE_NAME as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     query: 'Select * from DW.BREED_DIM',",
						"     format: 'query') ~> BreedDim",
						"BreedID aggregate(groupBy(BREED_ID),",
						"     SPECIES = first(SPECIES),",
						"          PRIMARY_BREED = first(PRIMARY_BREED),",
						"          SECONDARY_BREED = first(SECONDARY_BREED),",
						"          SOURCE_FILE_NAME = first(SOURCE_FILE_NAME),",
						"          LOAD_TIMESTAMP = first(LOAD_TIMESTAMP)) ~> aggregate1",
						"stagepet derive(BREED_ID = sha2(256, concat(\r",
						"    coalesce(SPECIES, ''),\r",
						"    '-',\r",
						"    coalesce(PRIMARY_BREED, ''),\r",
						"    '-',\r",
						"    coalesce(SECONDARY_BREED, '')\r",
						"))) ~> BreedID",
						"aggregate1, BreedDim join(aggregate1@BREED_ID == BreedDim@BREED_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 alterRow(insertIf(isNull(BREED_KEY)),",
						"     updateIf(!isNull(BREED_KEY))) ~> alterRow1",
						"alterRow1 sink(allowSchemaDrift: true,",
						"     validateSchema: true,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['BREED_ID'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     stageInsert: true,",
						"     mapColumn(",
						"          BREED_ID = aggregate1@BREED_ID,",
						"          SPECIES,",
						"          PRIMARY_BREED = aggregate1@PRIMARY_BREED,",
						"          SECONDARY_BREED = aggregate1@SECONDARY_BREED,",
						"          SOURCE_FILE_NAME = aggregate1@SOURCE_FILE_NAME,",
						"          LOAD_TIMESTAMP = aggregate1@LOAD_TIMESTAMP",
						"     )) ~> sink1"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/ls_snowflake_pet')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Customer_Dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "snowflake_chinook_ds",
								"type": "DatasetReference"
							},
							"name": "CustomerStage"
						},
						{
							"dataset": {
								"referenceName": "snowflake_chinook_ds",
								"type": "DatasetReference"
							},
							"name": "sourceCustomerDIm"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "snowflake_chinook_ds",
								"type": "DatasetReference"
							},
							"name": "FinalStageSnowFlake"
						}
					],
					"transformations": [
						{
							"name": "addhash"
						},
						{
							"name": "joinstagetarget"
						},
						{
							"name": "filterchanged"
						},
						{
							"name": "alterRowRules"
						},
						{
							"name": "addsurrogateKey"
						},
						{
							"name": "select1"
						},
						{
							"name": "AddAuditColumns"
						}
					],
					"scriptLines": [
						"parameters{",
						"     table_name as string ('CUSTOMER_DIM')",
						"}",
						"source(output(",
						"          CUSTOMERID as decimal(38,0),",
						"          FIRSTNAME as string,",
						"          LASTNAME as string,",
						"          COMPANY as string,",
						"          ADDRESS as string,",
						"          CITY as string,",
						"          STATE as string,",
						"          COUNTRY as string,",
						"          POSTALCODE as string,",
						"          PHONE as string,",
						"          FAX as string,",
						"          EMAIL as string,",
						"          SUPPORTREPID as decimal(38,0),",
						"          CREATED_BY as string,",
						"          CREATED_DT as date",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table') ~> CustomerStage",
						"source(output(",
						"          CUSTOMER_KEY as decimal(10,0),",
						"          CUSTOMER_ID as decimal(10,0),",
						"          FIRST_NAME as string,",
						"          LAST_NAME as string,",
						"          COMPANY_NAME as string,",
						"          CITY as string,",
						"          STATE as string,",
						"          COUNTRY as string,",
						"          ZIP_CODE as string,",
						"          EMPLOYEE_ID as decimal(10,0),",
						"          IS_ACTIVE as string,",
						"          SOURCE_ID as string,",
						"          DATE_TO_WAREHOUSE as timestamp,",
						"          ROW_HASH as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'table') ~> sourceCustomerDIm",
						"CustomerStage derive(source_hash_value = md5(\r",
						"    concat(\r",
						"        toString('CUSTOMERID'),\r",
						"        toString('FIRSTNAME'),\r",
						"        toString('LASTNAME'),\r",
						"        toString('COMPANY'),\r",
						"        toString('ADDRESS'),\r",
						"        toString('CITY'),\r",
						"        toString('STATE')\r",
						"    )\r",
						")) ~> addhash",
						"addhash, sourceCustomerDIm join(CUSTOMERID == CUSTOMER_ID,",
						"     joinType:'left',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'right')~> joinstagetarget",
						"joinstagetarget filter(isNull(ROW_HASH) || source_hash_value != ROW_HASH) ~> filterchanged",
						"filterchanged alterRow(insertIf(isNull(ROW_HASH)),",
						"     updateIf(!isNull(ROW_HASH))) ~> alterRowRules",
						"select1 keyGenerate(output(CUSTOMER_KEY as long),",
						"     startAt: 1L,",
						"     stepValue: 1L) ~> addsurrogateKey",
						"alterRowRules select(mapColumn(",
						"          CUSTOMER_ID = CUSTOMERID,",
						"          FIRSTNAME,",
						"          LASTNAME,",
						"          COMPANY,",
						"          ADDRESS,",
						"          CITY = CustomerStage@CITY,",
						"          STATE = CustomerStage@STATE,",
						"          COUNTRY = CustomerStage@COUNTRY,",
						"          POSTALCODE,",
						"          PHONE,",
						"          FAX,",
						"          EMAIL,",
						"          SUPPORTREPID,",
						"          CREATED_BY,",
						"          CREATED_DT,",
						"          SOURCE_HASH_VALUE = source_hash_value,",
						"          CUSTOMER_KEY,",
						"          CUSTOMER_ID,",
						"          FIRST_NAME,",
						"          LAST_NAME,",
						"          COMPANY_NAME,",
						"          CITY = sourceCustomerDIm@CITY,",
						"          STATE = sourceCustomerDIm@STATE,",
						"          COUNTRY = sourceCustomerDIm@COUNTRY,",
						"          ZIP_CODE,",
						"          EMPLOYEE_ID,",
						"          IS_ACTIVE,",
						"          SOURCE_ID,",
						"          DATE_TO_WAREHOUSE,",
						"          ROW_HASH",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> select1",
						"addsurrogateKey derive(IS_ACTIVE = 'Y',",
						"          SOURCE_ID = 'CHINOOK',",
						"          DATE_TO_WAREHOUSE = currentTimestamp()) ~> AddAuditColumns",
						"AddAuditColumns sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:true,",
						"     upsertable:false,",
						"     keys:['CUSTOMER_KEY'],",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     stageInsert: true,",
						"     mapColumn(",
						"          CUSTOMER_ID,",
						"          FIRST_NAME = FIRSTNAME,",
						"          LAST_NAME = LASTNAME,",
						"          COMPANY_NAME = COMPANY,",
						"          CITY,",
						"          STATE,",
						"          COUNTRY,",
						"          ZIP_CODE = POSTALCODE,",
						"          EMPLOYEE_ID = SUPPORTREPID,",
						"          ROW_HASH = SOURCE_HASH_VALUE,",
						"          CUSTOMER_KEY,",
						"          IS_ACTIVE,",
						"          SOURCE_ID,",
						"          DATE_TO_WAREHOUSE",
						"     )) ~> FinalStageSnowFlake"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/snowflake_chinook_ds')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/Load_pet_location_Dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Parquet2snowflake",
								"type": "DatasetReference"
							},
							"name": "locationsource"
						},
						{
							"dataset": {
								"referenceName": "Parquet2snowflake",
								"type": "DatasetReference"
							},
							"name": "petlicensesource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ls_snowflake_pet",
								"type": "DatasetReference"
							},
							"name": "LocationStage"
						},
						{
							"dataset": {
								"referenceName": "ls_snowflake_pet",
								"type": "DatasetReference"
							},
							"name": "Petstage"
						}
					],
					"transformations": [
						{
							"name": "addtimeANDsource"
						},
						{
							"name": "addtimesource"
						}
					],
					"scriptLines": [
						"source(output(",
						"          state_fips as string,",
						"          state as string,",
						"          state_abbr as string,",
						"          zipcode as string,",
						"          county as string,",
						"          city as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     inferDriftedColumnTypes: true,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     wildcardPaths:['folder/location.parquet']) ~> locationsource",
						"source(output(",
						"          License_Issue_Date as string,",
						"          License_Number as string,",
						"          Animal_Name as string,",
						"          Species as string,",
						"          Primary_Breed as string,",
						"          Secondary_Breed as string,",
						"          Zip_Code as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'parquet',",
						"     wildcardPaths:['folder/petlicense.parquet']) ~> petlicensesource",
						"locationsource derive(LOAD_TIMESTAMP = currentTimestamp(),",
						"          SOURCE_FILE_NAME = 'Location') ~> addtimeANDsource",
						"petlicensesource derive(License_Issue_Date = toString(toDate(License_Issue_Date, 'dd-MMM-yy'), 'yyyy-MM-dd'),",
						"          LOAD_TIMESTAMP = currentTimestamp(),",
						"          SOURCE_FILE_NAME = 'Petlicense') ~> addtimesource",
						"addtimeANDsource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     stageInsert: true,",
						"     mapColumn(",
						"          STATE_FIPS = state_fips,",
						"          STATE = state,",
						"          STATE_ABBR = state_abbr,",
						"          ZIPCODE = zipcode,",
						"          COUNTY = county,",
						"          CITY = city,",
						"          LOAD_TIMESTAMP,",
						"          SOURCE_FILE_NAME",
						"     )) ~> LocationStage",
						"addtimesource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     deletable:false,",
						"     insertable:true,",
						"     updateable:false,",
						"     upsertable:false,",
						"     truncate:true,",
						"     format: 'table',",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     stageInsert: true,",
						"     mapColumn(",
						"          LICENSE_ISSUE_DATE = License_Issue_Date,",
						"          LICENSE_NUMBER = License_Number,",
						"          ANIMAL_NAME = Animal_Name,",
						"          SPECIES = Species,",
						"          PRIMARY_BREED = Primary_Breed,",
						"          SECONDARY_BREED = Secondary_Breed,",
						"          ZIP_CODE = Zip_Code,",
						"          LOAD_TIMESTAMP,",
						"          SOURCE_FILE_NAME",
						"     )) ~> Petstage"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/datasets/Parquet2snowflake')]",
				"[concat(variables('factoryId'), '/datasets/ls_snowflake_pet')]"
			]
		}
	]
}